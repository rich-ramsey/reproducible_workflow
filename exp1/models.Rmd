---
title: "models"
author: "Rich"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This file builds a Bayesian multi-level model for an old gaze-cueing experiment 
that Andrew and some masters students completed.

# load the libraries that we will be using #

```{r load-pkg}
pkg <- c("cmdstanr", "standist", "tidyverse", "RColorBrewer", "patchwork", 
         "brms", "tidybayes", "bayesplot", "future", "parallel")

lapply(pkg, library, character.only = TRUE)
```

# set options #

```{r set-options}
options(brms.backend = "cmdstanr",
        mc.cores = parallel::detectCores(),
        future.fork.enable = TRUE,
        future.rng.onMisuse = "ignore") ## automatically set in RStudio

supportsMulticore()

detectCores()
```

## read in data and create factors where necessary ##

create a variable for stim and condition that uses deviation coding. 

And create a new variable that centres and standardises the dv.

```{r read-data}
datad <- read_csv("exp1/data/fdata.csv") %>% 
  mutate(stimd = if_else(stim == "arrow", -0.5, 0.5),
         compatd = if_else(compat == "compat", -0.5, 0.5)) %>% 
  select(pid, stim, stimd, compat, compatd, rt) %>% 
  mutate(c = rt - mean(rt),
         cs = (rt - (mean(rt))) / sd(rt))
head(datad)

# write_csv(datad, "exp1/data/datad.csv")
```

## load in previously saved models (as necessary) ##

This is useful if you want to look at aspects of a previously compiled model

```{r load-models}
## e.g.,
# b0 <- readRDS("exp1/models/b0.rds")
# b1 <- readRDS("exp1/models/b1.rds")
# b2 <- readRDS("exp1/models/b2.rds")
```

## build some models ##

At this point it is worth remembering that we are using gaussian / normal models
below just for simplicity. RT data would probably be better modelled by a bunch of
other distributions. But our focus here is not on that, so we'll keep it simple.

## b0 - intercepts only, centred and standardised units ##

# formula #

```{r b0-formula}
formula = bf(cs ~ 1)
```

# check the priors available #

```{r b0-get-priors}
get_prior(formula,
          data = datad, family = gaussian())
```

## visualise priors ##

here we would normally visualise priors of interest to make a judgment about what
would constitute weakly informative priors. 

```{r b0-vis-priors}
visualize("normal(0, 0.5)", "normal(0, 1)", "normal(0, 2)", 
          xlim = c(-4, 4))
```

(0,1) for the intercept provides good coverage for what we might expect
for the intercept or mean RT.

## set priors ##

```{r b0-set-priors}
priors <- c(
  set_prior("normal(0, 1)", class = "Intercept"),
  set_prior("normal(0, 1)", class = "sigma")
)
```

# run the model #

```{r b0-model}
plan(multicore)
b0 <- brm(formula = formula,
        data = datad, family = gaussian(),
        prior = priors,
        iter = 2000, warmup = 1000, cores = 8, chains = 4,
        save_pars = save_pars(all=TRUE),
        seed = 123,
        file = "exp1/models/b0")
summary(b0)
```

## take a look ##

chains

```{r b0-chains}
plot(b0)
```

pp check

```{r b0-pp-check}
pp_b0 <- pp_check(b0, ndraws = 100)
pp_b0
```

not a great fit for the reasons outlined above about the choice of model. That's
not important right now.


## b1 - full model, centred and standardised units ##

full model here just means the maximum varying effects structure. See Barr et al.,
2013 for justification. 

# formula #

```{r b1-formula}
formula = bf(cs ~ 1 + stimd*compatd +
               (1 + stimd*compatd | pid))
```

# check the priors available #

```{r b1-get-priors}
get_prior(formula,
          data = datad, family = gaussian())
```

## set priors ##

I use my usual 0,0.5 for slopes. 0,1 for sd. usual for cor.

```{r b1-set-priors}
priors <- c(
  set_prior("normal(0, 1)", class = "Intercept"),
  set_prior("normal(0, 0.5)", class = "b"),
  set_prior("normal(0, 1)", class = "sd"),
  set_prior("normal(0, 1)", class = "sigma"),
  set_prior("lkj(2)", class = "cor")
)
```

# run the model #

```{r b1-model}
plan(multicore)
b1 <- brm(formula = formula,
        data = datad, family = gaussian(),
        prior = priors,
        iter = 4000, warmup = 2000, cores = 8, chains = 4,
        save_pars = save_pars(all=TRUE),
        seed = 123,
        file = "exp1/models/b1")
summary(b1)
```

## take a look ##

chains

```{r b1-chains}
plot(b1)
```

pp check

```{r b1-pp-check}
pp_b1 <- pp_check(b1, ndraws = 100, type = "dens_overlay_grouped",
                    group = "compatd")
pp_b1
```


## b2 - full model, original rt units ##

full model here just means the maximum varying effects structure. See Barr et al.,
2013 for justification. 

# formula #

```{r b2-formula}
formula = bf(rt ~ 1 + stimd*compatd +
               (1 + stimd*compatd | pid))
```

# check the priors available #

```{r b2-get-priors}
get_prior(formula,
          data = datad, family = gaussian())
```

## visualise priors ##

here we would normally visualise priors of interest to make a judgment about what
would constitute weakly informative priors. 

let's do that for the intercept

```{r b2-vis-intercept-priors}
visualize("normal(600, 100)", "normal(600, 150)", "normal(600, 200)", 
          xlim = c(0, 1200))
```

And fixed effects

```{r b2-vis-effect-priors}
visualize("normal(0, 25)", "normal(0, 50)", "normal(0, 100)", 
          xlim = c(-200, 200))
```
## set priors ##

I use my usual 0,0.5 for slopes. 0,1 for sd. usual for cor.

```{r b2-set-priors}
priors <- c(
  set_prior("normal(600, 150)", class = "Intercept"),
  set_prior("normal(0, 50)", class = "b"),
  set_prior("normal(0, 150)", class = "sd"),
  set_prior("normal(0, 150)", class = "sigma"),
  set_prior("lkj(2)", class = "cor")
)
```

# run the model #

```{r b2-model}
plan(multicore)
b2 <- brm(formula = formula,
        data = datad, family = gaussian(),
        prior = priors,
        iter = 4000, warmup = 2000, cores = 8, chains = 4,
        save_pars = save_pars(all=TRUE),
        seed = 123,
        file = "exp1/models/b2")
summary(b2)
```

## take a look ##

chains

```{r b2-chains}
plot(b2)
```

pp check

```{r b2-pp-check}
pp_b2 <- pp_check(b2, ndraws = 100, type = "dens_overlay_grouped",
                    group = "compatd")
pp_b2
```

